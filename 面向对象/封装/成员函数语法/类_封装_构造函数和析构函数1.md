类_封装_构造函数和析构函数1

# 构造函数
## 语法
``类名(){}`` 
1. 没有返回值类型，也不需要写void。
2. 可以有参数，可以重载。
3. 写在类里面，函数名需要和类一致
4. 构造函数用来初始化对象
5. 创建对象时，自动调用构造函数，主要用来对对象进行初始化操作。
6. 当创建对象时，若构造函数存在参数，则必须传入。
7. 若没写构造函数，编译器会自动执行一个空的构造函数。
8. 构造函数有参数时，必须写在前面。而且要写在public中。
## 构造函数的分类和调用
### 构造
1. 按参数分类
    1. 有参构造
    2. 无参构造
2. 按类型分类
    1. 拷贝构造
    3. 普通构造
### 调用
这里涉及到几个不同的语法，容易混淆
如 
```c++
person p1();//表示声明一个person类型的函数p1。
person p1; //表示创建一个名字为p1的对象。
person p1(52);//这就是括号法，先创建对象，再向构造函数中传入变量
person p1( int p ); //表示创建一个person类型的名称为p1的函数。
person (52);//表示创建一个对象，对象没有名字，但向构造函数中传入了数值。称为匿名对象。
```
#### 匿名对象
指没有对象名的对象 如
``` c++
person (36);  person();  person;
```
上面三种都可以声明对象，但是对象没有名字。
1. 匿名对象在当前句执行完毕之后就立刻销毁。
2. 匿名对象不能使用拷贝函数赋值 例如 ``person(p3) == person p3``编译器不会识别小括号。
#### 调用的具体方法
1. 括号法
如 
```c++
person p； //直接声明一个变量，系统自动调用构造函数，注意不要加（）！
person p1(52); //声明变量的同时加（）里面填需要传入的数值！	
```
2. 显示法（顾名思义，是让匿名的对象显示出来的意思）
```c++
person p = person(52);
person p = person(52,ol);
```
3. 隐式转换法
```c++
person p4 = 10 ; //相当于在声明对象的同时，向构造函数中传入了10。
person p4 = { 12 , 54 } //当拥有多个参数时的写法。
```
### 拷贝构造函数
#### 语法
```c++
person(const person &p){ } //仍然以person为例子。
person(const person *p){ }//引用和指针都可以。要使用常量！
```
被传入的数值不能改变，因此使用const设计一个常量指针。
1. 用已经初始化的对象来创建一个新对象 如
    ```c++
    class person
	{
	private:
		m_age;
	public:
		person (const person &p) //拷贝构造函数。
    {
		m_age = p.age;
    }
    int main()
	{
		person p1; //创建一个新对象，假设已经初始化了。
		person p2(p1); //调用p1对p2进行初始化。
	}
    
    ```
2. 值传递的方式给函数传值
函数值传递时，会拷贝一个形参，赋值给实参。
    ```c++
    void dowork( person p ) //一个形参为p的空函数
	{
	
    }
	int main()
	{
	 person p1; //创建一个对象，会调用默认的构造函数。
	 dowork(p1); //将对象传入函数，相当于做了 person p = p1 的操作（隐式转换法），相当于声明变量p的同时，向构造函数中传入了p1，（形参不影响实参，因为是两个不同的变量。）即调用了拷贝函数。
	}
	
    
    ```
3. 值方式返回局部对象
    ``` c++
    //当以值的方式返回局部对象时，会将值拷贝出来再返回，原来的对象被销毁。
    person dowork() //定义一个返回值为person的函数。
	{
		person p1;
		return p1; //当值返回时，执行person p = p1;的操作，调用拷贝构造函数。
	}
    int main()
	{
		person p2 = dowork();
	}
    ```
### 构造函数的调用规则
1. c++编译器默认提供无参构造函数和拷贝构造函数，析构函数，这三个函数。
2. 用户创建有参构造函数时，编译器将不再提供无参构造函数。
3. 用户创造拷贝构造函数时，编译器将不再提供其他任何构造函数。

# 析构函数
## 语法 
``~类名(){}``
1. 没有返回值类型，也不需要void。
2. 不能有参数，不能重载。
3. 写在类里面，函数名和类名一致。
4. 析构函数用来清理对象。
5. 当对象即将被销毁时(函数执行完毕时)，自动调用析构函数。
6. 当没写析构函数，编译器自动执行一个空的析构函数。