类_封装_构造函数和析构函数2

### 深拷贝和浅拷贝
编译器提供的拷贝是浅拷贝
用户提供的拷贝是深拷贝
1. 浅拷贝的弊端
    ### 代码实例
    ``` c++
    class person
    {private:
	    int m_age;
	    int* m_height;  //使用指针的方式开辟一个变量height。
    public:
	    person(int age ,int height) //有参构造函数，初始化变量。
	    {
		    m_age = age;
		    m_height = new int( height ); //在堆区开辟一个数据。
		    cout << "有参的构造函数" << endl;
	    }
	    ~person() //析构函数
	    {
		    cout << "析构函数的调用" << endl;
		    if (m_height != NULL) //当为空指针时。
		    {
			    delete m_height; //清理堆区的数据。
			    m_height = NULL; //防止野指针的出现。
		    }
	    }
    };
    void test01()
    {
	    person p1(25, 160); //创建一个对象，将他通过构造函数初始化。
	    person p2(p1); //创建一个对象，将他通过拷贝构造函数初始化。
		
    }
    ```
程序中存在的问题：通过拷贝的方式初始化p2的过程中，拷贝出的是p1的地址，因此p1和p2指向的是同一块内存。在析构时，同一块内存被delete了两次，因此会报错！

2. 深拷贝
深拷贝的方式可以解决浅拷贝重复释放的问题
``` c++
//深拷贝
//在类中写一个拷贝函数，重新开辟一块内存存放地址。
person(const person & p)
{
	m_age = p.m_age;
	m_height = new int(*p.height) //p.height的数据类型为指针，要解引用转换成int。开辟出一块新的内存，将内存的地址返回给m_height。 
}
//浅拷贝
person(const person & p)
{
	m_age = p.m_age;
	m_height = p.height; //直接将地址赋值给m_height。导致拷贝前和拷贝后指向同一块内存。
}
```