# 简单介绍
## 用途
给变量起一个别名
## 语法
数据类型 &别名 = 真名 ; 如``int &b = a ;``
1. b与a操纵同一块内存
2. 被引用的变量比须经过初始化 如``int &b ;``是错误的。
3. 引用一旦初始化后，不可以更改。即同一个别名不能是两个变量的别名 如``int a = 20; int c = 60; int & b = a; b = c //这是赋值，不是更改引用！`` 是错误的。
4. 引用必须引用一块合法的内存空间 如``int & b = 10; ``是错误的。
## 引用做函数参数
### 介绍
让形参修饰实参，不必使用指针。这样传递的方式被称为**引用传递**。
1. 值传递，形参和实参都是用普通的方式定义的，形参和实参实际上是不同的变量。形参不能改变实参。
3. 地址传递，形参是指针，传入的是地址。传入的是实参的地址，指针在操作时指向实参地址。可以对实参进行改变。
4. 引用传递，传入的是一般变量，形参是引用。引用不会另外开辟内存。
### 代码实例
``` c++
void func( int &a ) //定义引用。
{
	//代码串，可以对传入的实参进行修改。
}
int main()
{
	int a ;
	func ( a ); //直接传入即可。
}
```
## 引用做函数的返回值
1. 不要返回局部变量的引用，已经被释放了！
2. 返回值为引用的函数作为左值可以被修改。 如
``` c++
int & fuuc() //定义一个返回值类型为引用的函数。
{
	static int a = 10 ; //定义一个静态局部变量，防止函数结束后被释放。
	return a ; //将引用返回。
}
int main()
{
	int & ref = func(); //定义一个引用来接收func()的返回值。
	cout<< ref <<endl; //输出ref ，此时结果应该为10。
	func() = 1000; //修改返回值的值。
	cout<<ref<<endl; //ref引用func()，因此ref的输出结果也会变为1000。
}

```
## 引用的本质
1. 相当于指针常量，指针的指向不能改变，值可以改变。
`` int * const p = &a ``等价于 ``int & p = a``。 
2. 修改引用的值的时候相当于指针解引用后修改值。
`` * p = 10 ;p是指针。`` 等价于 ``p = 10; //p是引用。``

## 常量引用
### 使用场景 
1. 修饰形参防止误操作。
2. 代码案例
``` c++
void func(const int & a )//传入一个变量，传入时把他定义为常量。
{
	//代码块
}
```
