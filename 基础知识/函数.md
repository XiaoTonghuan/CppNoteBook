# 概述
将一段经常使用的代码进行封装，减少重复代码
将一个大型的程序分为若干个程序块，每个程序块实现特定的功能

# 定义
1. 返回值类型（可以是 指针，引用，变量，无等。）
2. 函数名
3. 参数列表 （传入时可以传入常量和变量）
4. 函数体语句
5. return 返回值
```c++
返回值类型 函数名 (参数列表,就是你需要输入的值)
{
    结构体语句
    return 表达式 //这是程序返回的值
}
```
## 举例
定义一个加法函数
返回值类型 int
函数名 add
函数列表 （int num1,num2）
函数体语句 int sum=num1+num2
return 表达式 sum

```c++
int add ( int num1,int num2 )
{
    int sum=num1+num2;
    return sum;
}
```
## 函数的调用
函数名( 参数 ) 即可实现调用
```c++
int a = 10,b = 25;
 c = add(a,b); //可以直接传入数值如add(10,25);
```
1. a，b是有具体数值的，调用函数后a，b的值会传递给num1，num2，经过表达式运算后通过return返回运算结果，再用c接收。
2. 其中num1,num2被称为形参，因为他们没有具体的数值；a，b被称为实参，是因为他们是有实际数值的变量。
3. 如果函数不需要返回值声明返回值类型时可以写void。可以不写return。

## 值传递
形参发生任何改变，不会影响实参的值
```c++
void swap( num1, num2)
{
cout<<"交换前的值为num1 = "<<num1<<"num2"<<num2;
    int temp = 0;
    temp = num1;
    num1 = num2;
    num2 = temp;
cout<<"交换后的值为num1= "<<num1<<"num2 ="<<num2;
}
int main()
{
    swap (a,b);
    cout<<a<<b;
}
```
你会发现交换完a，b的值后，实际上交换的时num1和num2的值，对a，b原来的值没有影响。
### 值传递的本质
***将实参的值拷贝，创造出一个新的变量（形参）将值赋值给形参。值得一提的是当函数的返回值是以值传递的形式返回时，也是同样。*** 

## 函数的声明
1. 函数只能定义一次，函数能无数次声明。
2. 为了避免执行主函数时找不到定义的函数。将定义的函数放在主函数后面，在主函数前面声明，起到使清晰结构的作用。
3. 将定义中{}以及里面的内容去掉即为声明。如``void swap(num1, num2)``，就完成了对一个函数的声明。
## 函数的分文件编写
利用头文件（写声明，后缀为.h），源文件（写定义，后缀为.cpp）完成对一个函数的书写，可以使这个函数能够被其他项目调用。
### 头文件的书写
1. 开头加上#include< iostream >等必加的头文件，避免定义时出错。
2. 只需书写函数的声明

### 源文件的书写
1. 需要调用头文件，具体方法为在开头加上#include" 这里面写头文件的名称 "如头文件名称为``swap.h``源文件就要写#include"swap.h" ，从而将头文件和源文件关联起来" "表示这个库是自定义的。
2. 其他项目调用函数时，只需要在开头加#include" 这里面写头文件的名称 "，即可实现函数的调用。

## 函数默认参数

形参可以设置默认值。
### 代码
```c++
void printval(int a = 10, int b = 638)
{
	cout << a << endl;
	cout << b << endl;
}
int main()
{
	printval(); //你甚至可以在有初始化的情况下，不向里面传入任何数据。当你传入任何数据，将覆盖初始值。
    printval(a);//打印的a为传入的a，b为默认值。
}
```
### 注意事项
1. 某一个形参有默认参数，从这个形参之后都要有默认参数 如
``void func(int a = 10 ,int b,int c) `` 是错误的。也就是说默认参数的添加要从右向左
2. 声明和实现只能有一个有默认参数（重复定义，歧义） 如
``` c++
void func(int a = 10,int b = 10);
void func(int a = 10 ,int b = 10 )
{
    cout<<a<<endl;
}
```
是错误的。
## 函数的占位参数
字面意思，起占位的作用
### 代码
``` c++
void func(int a, int)//没有形参名字的起占位的作用
{
	cout << "hello world" << endl;
}
```
### 注意
1. 占位参数可以有默认函数 如``void func( int = 10 ) {}`` 是正确的。

## 函数重载
调用函数值相同但是形参不同的函数
1. 函数名必须相同
2. 参数的数量，数据类型，位置，都可以作为重载的条件。
3. 返回值类型不能作为重载的条件。
4. 必须在同一个作用域下。
5. 引用下的重载。
```c++
void func(int &a)
{
	cout << "hello world" << endl;
}
void func(const int &a)
{
	cout << "hello world" << endl;
}
//上述两个不是同一个函数
func( 10 ); //十是常量，因此调用的是第二个。
int a = 10;
func(a);//a是变量，调用的是第一个。
const int a = 10;
func(a);//a是常量，调用的是第二个。
```
6. 函数重载碰上默认参数，可能会造成歧义
``` c++
void func(int a = 10){}
void func(){}
//如这两个函数当你使用func();时，并不能明确调用的是哪一个函数。
```
### 代码
```c++
void func(int a, int)
{
	cout << "hello world" << endl;
}
void func() //个数不同。
{
	cout << "hello world" << endl;
}
void func(double a,int b) //顺序类型不同。
{
	cout << "hello world" << endl;
}
void func(int a,double b)
{
	cout << "hello world" << endl;
}
```
