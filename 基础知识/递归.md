# 递归介绍

- 什么是递归

  递归就是自己调用自己

- 为什么要使用递归

  1. 使用递归可以增强代码的可读性
  2. 解决一些其他方法不能或者很难解决的问题

- 递归的使用
  1. 当一个问题的子问题与原问题是同样的问题时，使用递归。
  2. 使用递归时，必须书写递归边界，防止死循环。

- 递归有什么缺点

  递归的时间复杂度较高，虽然增强了可读性，但是增加了内存占用。

# Fibonacci

```c++
//递归的几个小例子
#include <iostream>
using namespace std;
 //例子1 ，斐波那契数列 ，求数列的第n项
 int Fibonacci ( int  n ) //有返回值，下面要写一个变量来接受他。 
 {
 	if ( n == 0 ) return 1; //数列的前两项都为一 
 	else if ( n == 1 ) return 1;
 	else return n+ Fibonacci  ( n-1 ) + Fibonacci  ( n-2 ) ; //这里要写成最后一项加前两项的形式。 
}

//方法2 使用循环 
void Fibonacci1 ( int n )
{
	int a,b,c ; //定义3个变量记录要求的一项和他的前两项。
	a = 1; b =1; //令前两项初值为1。 
	for(int i = 1 ; i <= n-2 ; i++ ) //循环n-2次，循环一次是求出第三项的值，因此要求出第n项要循环n-2次。 
	{
	c = ( a + b ); //先求出第n项 
	a = b; //先令n-2项改变 
	b = c; //令第n-1项改变 
}
cout<<c;
 } 
 //方法3 记忆化搜索 
 int Fibonacci2 ( int n ,int a[] ) //函数体内使用了数组，传入一个数组。 
 {
 	const int max = 101 ; //定义数组的长度 
    if(a[100] != -1) //给数组初始化 
	{
	  
 	for (int i = 0 ; i < max ; i++)
 	{
 		a[i] = -1 ;
	 }
}
 	a[1] = 1; a[2] = 1; //让数组的第二项和第三项等于1，放弃第一项。 
 	if (a [n] != -1 ) return a[n] ; //判断数据是否被记忆，是就调用被记忆的数据。 
 	else
 	{
 		a[n] = Fibonacci2 (n-1 , a ) +Fibonacci2 ( n-2 , a ) ; //记忆数据 
 		return a[n] ;  //返回结果。 
	 }
 	
} 
```

# 进制转换

1. 采用数字拼接的方式 

``` c++
int change ( int  a  ) //在这里我并不想使用直接在屏幕中打出该数除以2后的余数的方式。 
{
	int log = 0 ;  //先求出以2为底a的对数，为之后以返回整型二进制数做铺垫。 
	for ( int i=2 ; i<= a ; i *= 2 )
		log++ ;
	// 用乘方的方式模拟了求对数的过程。 
	int figue = 10 ; //给每一位的数字乘上10的倍数。
	for ( int j = log ; log > 0 ; log-- )
		figue *= 10;
	if ( a / 2 == 1 || a/2 == 0 ) return 1 ; //递归边界 
	else return ( (a%2) * figue + change(a/2) ) ; //直接算出二进制数。
}
```

2. 采用直接打出的方式 

``` c++
void change1 ( int a )
{
	if (a/2 == 0) cout<<1; //递归边界
	else
    {
		cout << a%2 ; //求出余数，从左到右打出。
		change1 ( a/2 ) ; //调用自身。
	}
 } 
```

# hanoi

## 问题描述

从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，期间只有一个原则：一次只能移动一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数。

## 分析

有n个盘子，设拿走他们要花费p(n)步先，拿走上面的n-1个盘子，花费p( n-1 )步，将最下面的盘子放入目标的塔上，花费一步，再将那n-1个盘子放到目标盘子上，花费p(n-1)步。所以有p(n)=2*p(n-1)+1。其中p(1)=1。

## code

``` c++
int hanoi ( int n )
{
	if( n == 1 ) return 1; //递归边界。
	else return (1 + 2*hanoi( n-1 )) ; //将数学表达式带入其中。
}
```



