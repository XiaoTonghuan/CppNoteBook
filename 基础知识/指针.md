# 指针的定义和使用
## 概述
指针是用来反应变量地址的变量（其实并不是很明白指针究竟能不能再被称之为变量）

## 定义
数据类型 * 指针名 如``int * ptr``  //含义为int的指针。
``` c++
int a = 0;
int * p;  
p = &a //将a的地址存入指针p中,可以直接将两句合写为 int * p = &a;+
cout<<p<<endl;//结果将会是a的地址
```
## 指针的解引用

1. 可以通过取值符“ * ”，将指针所代表的地址指向变量。如``cout<< * p <<endl;`` 你将会得到变量a的值。
2. 可以写* p = 1000;那么你的输出变量a的值也是1000，即使你并没有对a进行赋值操作。
## 指针所代表的空间
1. 32位环境下大小位4bytes，64位环境下为8bytes。（x86就是32位！）

2. 指针的大小和数据类型无关。如``sizeof(char *)==sizeof(int *)`` 注意（）里既可以填数据类型也可以填写变量名哦。如 ``sizeof( ptr ) ``也是可以的。
3. 解引用之后就是所指向的数据类型所占用的空间``sizeof(*ptr)``。结果应该是ptr所指向的数据类型所占用的字节数。

# 空指针和野指针
## 空指针
1. 空指针指向内存中编号为0的空间。
2. 用来初始化指针变量
``` c++
int * p = null；//即初始化指针，现在指针指向的地址编号为0.
```
3. 空指针是不可以访问的（0-255之间的内存编号系统占用的空间）如
```c++
int * p = null；
* p = 100；
cout<<* p <<endl; //会报错
```
## 野指针
指针指向了一块非法的空间（你没有权限去操作这些空间）
``` c++
int * p =( int * )0x1542；//即使你后面写的是16进制的数，也必须强转成指针类型，直接说明了指针不是变量。
cout<<* p <<endl; //我直接报错！
```
# const 和 指针
1. const 修饰指针，称为**常量指针**,意思就是，指针的指向可以改，但是指针指向的值不可以改。
```c++
int a = 10;
int b = 5;
const int * p = &a; //const在前指针变量在后，因此叫常量指针。
    //实际上该写法也等价于 int const * p = &a 这也是常量指针。
p = &b; //这句是改的指针的指向，让指针指向了b，地址是b的。
* p = 100;// const int * p = &a；之后不能对指针指向的值有任何操作，直接报错！ 
b = 52;// 但是可以对b的值进行修改
cout<<*p<<endl; //这时输出结果为b的值。指针指向了b。
```
2. const修饰常量，称为**指针常量**，指针的指向不可以改，指针指向的值可以改。
``` c++
int a = 5;
int * const p =&a; //指针变量在前，const在后，因此叫做指针常量。
p = &b; //这句不能写，直接报错！不能修改指针的指向。
* p = 100 ; //这句是对的，可以修改指针的指向，改完了之后，再输出a的值，发现a的值也变成了100.
```
3. const即修饰指针，又修饰常量
``` c++
const int * const p = & a;//指针的指向和指针指向的值都不能修改。
```
不大好记，可以这样记。
1. const在" * "之后" 指针名 "之前，修饰的是指针，不是指针指向的值。
2. const在" * "之前，修饰的是指针指向的值。
3. 脱离定义后*p是指针指向的值（*p是常量啊岂可休！！），p是指针。
# 指针和数组

数组名是一个指针常量，指向的内存不可以改变，因此所有适用于指针常量的语法都适用于数组，适用于数组的语法也都适用于指针常量。
## 利用指针访问数组中的元素。

``` c++
int shuzu[6] = {1,2,3,4,5,6} ; //定义一个一维数组，并初始化。
 cout<<shuzu[0]<<endl; //根据学过的知识，可以直接利用数组名和下标来实现对数组的调用。 
 //由于数组名，在这里是shuzu，直接输出就是首地址所以可以直接写
 int * p = shuzu; //这里是定义加赋值，别理解错成解引用了。指针指向数组的首地址。
 cout<<"利用指针访问数组中的第一个元素"<<* p <<endl; //shuzu默认为第一个元素的地址
 p = &shuzu[2]; 
 cout<<"利用指针访问数组中任意一个元素"<<* p <<endl; 
 p++; //让指针向后偏移4个字节，好像不一定是4个，总之就是从指shuzu[2]变成指向shuzu[3]了。
 cout<<"现在访问的应该是shuzu[3]"<< * p <<endl;
 
 //利用指针遍历一个数组 
 int * p1 = shuzu ;
 for(int i=0;i<=5;i++)
 {
    cout<<*p1<<endl;
    p1++;
 } 
 //也可以这样写，没错指针数组是能加下标的！！
	int lenth = sizeof(shuzu) / sizeof(shuzu[0]) ;
	int *p = shuzu ; //或者 int *p = &shuzu[0];
	for( int i = 0 ; i< lenth ; i++ )
	{
		cout<<p[i]<<endl; //指针数组能加下标。输出的是值，不是地址，也不用解引用。
	}
```
## 直接创建一个数组指针
```c++
int (*b)[5]; //创建一个指针，在后面开辟5*sizeof(int)大小的空间
```

# 指针和函数（地址传递）

利用指针可以改变实参的值

``` c++
#include<iostream>
using namespace std;
void bubblesort( int * arr , int lenth); 
void sortresult ( int *arr , int lenth );
int main()
{
	int arr[12] = {1,2,5,9,622,365,14,25,478,36521,23,1} ;
	int lenth = sizeof(arr) / sizeof(arr[0]) ;
	bubblesort ( arr , lenth );
	sortresult ( arr, lenth );
}
void bubblesort( int * arr, int lenth)
{
	for( int i = 0 ; i< lenth - 1 ; i++ )
	{
		for( int j = 0 ; j < lenth - i - 1 ; j++ )
		{
			
			if( arr[j] > arr[j+1]) //这里的arr调用的是指针的arr。
			{
			    int temp = arr[j] ;  //这里应该写j，别犯傻写成i了。 
				arr[j] = arr[j+1] ;
				arr[j+1] = temp ;
				
			}
			
		} 
	} 
}
void sortresult ( int *arr , int lenth )
{
	for( int i = 0 ; i< lenth ; i++ )
	{
		cout<<* arr<<endl;
      arr++ ； //这里应该也是调用的是指针的arr 
	}
 } 
```
# 结构体指针
## 结构体指针的定义和使用
1. 定义 ：struct 结构体名 * 结构体指针名 
如`` struct student * p``
2. 使用 ：我们可以利用* p的方式访问内置变量，在结构体中，这一方式变为 指针名->结构体内部变量名如 ``p->name`` 这一操作相当于 ``( * p ) = student.name``

# 指针和字符串
1. 字符串的返回值类型为地址，可以使用指针接收，接收之后变为，字符数组。打印指针直接输出字符串的所有内容
2. 指针数组（由指针构成的数组），可以用来方便的储存几个字符串的值
```c++
 char *ch[5];
    int lenth = sizeof(ch) / sizeof(ch[0]);
    for (int i = 0; i < lenth; i++)
        ch[i] = "strcat 函数真是蠢爆了";
    for (int i = 0; i < lenth; i++)
        cout << ch[i] << endl;
```
3. *ch[5] == char **ch;