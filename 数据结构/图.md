# 图的定义

## 图

图：由顶点$(Vertex)$和把顶点连起来的边$(egde)$构成的数据结构

表示：$graph(G) = (V,E)$

无向图：图的边没有方向

有向图：图的边有方向

完全图：

1. 从某个顶点出发，总有直接到达其他顶点的路径
2. 无向完全图：有$\frac{n*(n-1)}{2}$条边
3. 有向完全图：有$n(n-1)$条边
4. 稠密图：一个边数接近完全图的图边数$n*logn$
5. 稀疏图：一个边数远小于完全图的图

子图$(subgraph)$：主图的一部分$G1 = (V1,E1),G2=(V2,E2) ,\quad if V2\subseteq V1,E2\subseteq E1$ G2是G1的子图

简单图：没有重复边且顶点不连向本身的图，反之为复杂图

## 边

边的方向：

1. 有向：带箭头的线，箭头的一段是头，表示为<a,b>，$a\to b$ 。也常被称为**弧**
2. 无向：没有箭头的线，表示为(a,b)

权值$(weight)$：边的长度,带权的图被称为网

## 顶点

度$(Degree)$：

1. 与某个节点相连的边的个数
2. 记作$TD(V)$

2. 入度$ID(V)$：有向图中以某个顶点为终点的有向边的条数
3. 出度$OD(V)$：有向图中以某个顶点为起点的有向边的条数

邻接点$(Adjacent)$：**对于无向图**，相邻的点为邻接点，连结着两个顶点的边依附$(Incident)$于两个顶点，或者说边$(V1,V2)$和顶点$V1，V2$相关联

路径$(Path)$：

1. 从一个顶点到达另外一个顶点的方法
2. 路径的长度：路径上边或者弧的数目

回路（环）$(Cycle)$：

1. 起点和终点相同的路径
2. 简单环：除终点，其余的顶点在环上出现一次

连通：

1. **无向图中**，如果某个个顶点能以某种路径到达另一个顶点，那么这两个顶点相互连通

2. 连通图：顶点都连通的图
3. 强连通分量：最大的连通子图
4. 连通图生成树：n个顶点n-1条边的图，**可能**是一棵生成树
5. 有向树：**有向图**，恰有一个顶点入度为0，其他顶点入度为1

# 图的储存结构

## 邻接矩阵

用行数和列数来代表顶点之间的链接情况，如果是1，表示连通$G[i][j] = 1/0$

```c++
int G[101][101]{};
int n;
cin>>n;//这里n表示输入顶点的个数
for (int i = 1; i <= n; i++)
	for(int j = 1; j <= n; j++)
		cin>>G[i][j];
//or
int k,j,v;
for(int i = 1;i<=k;i++) //这里k表示要输入的边数。
{
    cin>>i>>j>>v;   //from / to / weight
    G[i][j]=w;
    G[j][i]=w;
    //无向图有对称性
}
```

- 对角线为0，没有自己到自己的边
- 无向图矩阵对称
- ``O(1)``判断两点之间是否有边

## 邻接表

- 动态数组邻接链表储存

  ```c++
  vector<int> G[6]; //一共有6个节点，每一个节点都是一个vector
  //每个节点的度G[i].size()
  //初始化
  int k = 0;
  int n = 0;
  cin>>n; //点的数量
  cin>>k; //边的数量
  for(int i = 0 ; i < k ; ++i)
  {
      int u,v;
      cin>>u>>v;
      G[u].push_bank(v);
      G[v].push_bacK(u);//单向图没有这一步
      //深搜时两个点分别是i和G[i][j] // j只是下标，不是标记的终点,然而i既是起点又是下标
  }
  //可以将int改为edge的结构体，用来储存到达的地方(to)和该店与from点的距离(distance)
  struct edge
  {
      int to;
      int distance;
  };
  ```

- 数组模拟邻接链表储存

使用一维线性表储存头，每个头控制着一条边（结构体/类），边数组里面储存着起点终点和边的权值

```c++
struct edge
{
	int from; //表示边的指向
	int to; //表示边的目的地
	int distance; //表示边的长
	int next; //
};
class Graph
{
private:
	int n;//顶点的数量
	int k; //边的数量
	edge edges[101]{}; 
	int head[101]{};
public:
	Graph(int n = 0, int k = 1) : n(n), k(k){}
	void AddEdge(int from,int to,int distance)
	{
		//制作一条边
		edges[k].from = from;
		edges[k].to = to;
		edges[k].distance = distance;
		//将边连上顶点，head[from]用来储存该节点下面边的条数
		edges[k].next = head[from]; //用来表示指向，储存的是上一次head[from]下的边数
		head[from] = k; //更新head[from]，相当于边数加一 
		k++; //对k进行增加，便于添加下一条边
	}
};
int main()
{
	int k,n;//边数,定点数
	cin>>k>>n;//读入边数
	Graph g(n); //初始边数0，这个k是第n条边的意思。
	for(int i=1; i<=k; i++)
	{
		int from;
		int to;
		int distance;
		cin>>from>>to>>distance;
		g.AddEdge(from, to, distance);
	}
}
```

# 图的遍历

## 深度优先遍历(DFS  Deep-First-Search)

先顺着每一条路向下找，找到底之后回溯一步向前一个节点的另一个分支继续向下找

```c++
const int maxn = 1e5;
bool vis[maxn]; //记录这个点有没有到过
vector<int> G[maxn];
int cnt=0;
void dfs(int x)
{
    vis[x] = true; //这个点我们已经来过了
    cnt++; //遍历的点的个数++;
    cout<<x<<" "; 
    if(cnt==n) return; //遍历完所有的点,直接退出
    
    for(int i = 0 ; i < G[x].size();++i) //遍历这个点伸出的所有的边
    {
  	    if(!vis[ G[x][i] ]) //如果这个点我们没有来过
       		dfs(G[x][i]); //遍历这个点
		//vis[G[x][i]] = false //回溯请加在这里    
    }
}
//这里不需要回溯，当一个状态会影响另一个状态的判断时，需要恢复到这个还没有到过这个点的状态

//dfs剪枝
//当一些分支从一开始就错了的时候，我们不需要再从错的地方向下走


```

## 广度优先遍历( BFS Breadth-First-Search)

```c++
#include<iostream>
#include<vector>
#include<queue>
using std::cin;
using std::cout;
using std::endl;
const int maxn = 1e5;
bool vis[maxn]; //记录这个点有没有到过
std::vector<int> G[maxn]{};
int cnt=0;
void bfs(int t) {
    std::queue<int> que;  //创建队列，发现bfs符合先进先出的规则
    que.push(t); //将第一个元素push
    vis[t] = 1;  //标记来过
    cout<<t<<" "; //输出
    while(!que.empty())  
    {
        int x = que.front();  //标记第一个元素用于遍历
        que.pop();  //出队
        for(int i = 0 ; i < G[x].size() ; ++i)  //遍历和该元素连通的元素
        {
            if(!vis[G[x][i]])  //没到过
            {
                que.push(G[x][i]);
                cout<<G[x][i]<<" ";
                vis[G[x][i]] = true;
            }
        }
    }
}
int main()
{
    int n,k;
    cin>>n>>k;//输入顶点数和边数
    for(int i = 0; i < k; ++i)
    {
        int from,to;
        cin>>from>>to;
        G[from].push_back(to); //创建两个顶点之间的关系
        G[to].push_back(from);
    }
    bfs(0);
	system("pause");
} 
```

## 欧拉路

一笔画点可以重复，路径不能重复

欧拉路：一个图存在一笔画

欧拉回路：一笔画回到起点

奇点：跟一个点相连的边数为奇数

定理：欧拉路存在的条件，图是连通的，有且只有2个奇点

定理：欧拉回路存在的条件：图是连通的，有0个奇点

1. 深搜

   ```c++
   int G[max][max];  //邻接矩阵存储
   int degree[max]; //记录顶点的度
   int path[max]; //记录路径
   int N,M;
   void dfs(int i,int deep){ //i代表点，deep代表递归的深度
       path[deep] = i; //将路径加入
       if(deep == M+1) return;  //成功走完
       for(int j = 1 ; j <= N ; ++j){  //试探
           if(G[i][j]){  //能走则走
               G[i][j] = 0;  //将边删去，避免重复
               G[j][i] = 0;
               dfs(j,deep+1);  //走下一个点
               G[i][j] = 1;  //回溯
               G[j][i] = 1;
           }
       }
   }
   
   //邻接表
   int vector<int> G[max];
   int N,M;
   void dfs(int i ,int deep){
       path[deep] = i;
       if(deep == M+1) return;
       for(int j = 0; j < G[i].size(); ++j){
           	int temp = G[i][j];
           	G[i].erase(temp);  //在顶点i的邻接点中删去temp点
           	G[temp].erase(i);  //在temp点的邻接点中删去j
               dfs(temp,deep+1);  //深搜temp点
     			G[i].push_back(temp);  //回溯
           	G[temp].push_back(i);  //回溯
       }
   }
   ```


## 哈密尔顿回路

哈密尔顿回路：不重复的走过所有的点，最后回到起点

注意点和边的不同的处理方法，点：数组标记，边：删去

```c++
int start;
int path[max]
int vector<int> G[max];
int N,M;
bool vis[max]
void dfs(int i ,int last,int deep){
    path[deep] = i;
    vis[i] = true;
    for(int j = 0; j < G[i].size(); ++j){
		if(!vis[G[i][j]]) //没走过继续搜
            dfs(G[i][j],i,deep + 1);
        else if(G[i][j] == start && G[i][j]!=last && deep == N){
            path[N+1] = start;
            //下面打印，不写
        }
    }
    vis[i] = false; //回溯
}
//几个特点，不能回头，可以通过标记点来实现
//哈密尔顿路径上的点可以重复，当且仅当这个点是起点也是终点并且不是回头
```

## 判断图是否是树 

```c++
#include<iostream>
#include<vector>
#include<cstdio>
using std::cin;
using std::cout;
using std::endl;
const int maxn = 1e5;
bool vis[maxn]; //记录这个点有没有到过
std::vector<int> G[maxn]{};
int colors[maxn]{}; //-1表示没在看,0表示正在看，-1表示访问完了
int dfs(int x)
{
    colors[x] = 0;
    
    for(int v : G[x])
    {
        if(colors[v] == 0) return false;
        else if(colors[v] == -1)
            if(!dfs(v))
                return false;
    }
    colors[x] = 1;
    return 1;
}

int main()
{
    for(int i = 0; i <maxn ; ++i)
        colors[i] = -1;
    int n,k;
    cin>>n>>k;//输入顶点数和边数
    for(int i = 0; i < k; ++i)
    {
        int from,to;
        cin>>from>>to;
        G[from].push_back(to); //创建两个顶点之间的关系
        //G[to].push_back(from);
    }
    cout<<dfs(1);
	system("pause");
} 
```

# 最小生成树(MST)

1. 什么是最小生成树

   用N-1条边链接n个点，形成的图形一定是树。

   一个具有N个点的有权无向图，最小生成树是从图的所有边中选择N-1条出来，链接所有的N个点，这N-1条边的边权之和是所有方案中最小的

2. 用来解决什么问题

   如何用最小的代价链接N个点的问题

   如要修建若干条高速公路把N个城市联系起来，问如何设计使得工程造价最小

## 克鲁斯卡尔(Kruskal)算法

巧妙利用并查集

1. Kruskal 首先初始化并查集，把N个点看做N个独立的集合，再将所有的边从小到大排序
2. 按顺序枚每一条边，如果这条边链接的两个点属于两个集合，那么就把这条边加入最小生成树，并且合并这两个集合；如果这条边链接的两个点属于同一个集合就跳过，直到选取了N-1条边为止

```c++
int k = 0; //记录边数
int ver; //记录顶点个数
int MST = 0; //记录边的权值之和
struct E {//边
    int u;  //起
    int v;  //终
    int w;  //权
} E[100];
cin >> N >> M; //输入顶点和边的总个数 
for(int i = 0 ; i < k  ; ++i)
    cin>>E[i].u>>E[i].v>>E[i].w;
for(int i = 0 ; i < N ; ++ i){ //输入顶点值并且初始化集合
    int x;
    cin>>x;
    parent[x] = x;
}
//按边的权值从小到大进行排序

//排序不写！！
//
//
for(int i = 0 ; i < M ; ++i){
    if(find(E[i].u) != find(E[i].v)){
        union(E[i].u,E[i].v);
        MST+=E[i].w;
        ++k;
    }
    if(N-1 == k) break;
}
//时间复杂度ElogE
```

## 普里姆(Prim)算法

贪心

蓝白点：蓝点代表没有进入最生成树的点，白点代表已经进入生成树的点

当所有点都变成蓝点时，已经全部进入最小生成树

```c++
int W[u][v] ; //表示边之权，不相连表示为无穷大
int Min[v] ; //表示某个蓝点v与白点相连的最小权，因为开始没有白点所以初始化为无穷初始化Min[1] = 0
bool B[v] ; //表示蓝点(1)或者白点(0)
int MST = 0 ;  //表示权值之和

for(int i = 1; i<=N ; ++i){
    //寻找Min[k]最小的点k
    k = 0;
    for(int j = 1 ; j <= N ; ++j)
        if(B[j] && Min[j] < Min[k])
            k = j;
    B[k] = 0; //洗白点k
    MST+=Min[k];//累加权值
    //修改与k相连的所有蓝点
    for(int j = 1 ; j<=N ;++j)
        if(B[j] && W[k][j] < Min[j])
            Min[j] = W[k][j];
}
```



# 并查集

1. 查找代表元素

   ```c++
   int find(int x)
   {
       if(parent[x] == x)  //如果父亲是自己，直接返回自己
           return x;
       return find(parent[x]); //其他情况查找父亲的父亲
   }
   ```

2. 求并集

   ```c++
   void union(int x ,int y)
   {
       int x1 = find(x);
       int y1 = find(y);
       //找到x，y的祖先，并将y的父亲指向x
       parent[y1] = x1;
   }
   ```

3. 路径压缩

   在查找的过程中将递归层数缩短

   ```c++
   int find(int x){
       if(parent[x] != x)  
           parent[x] = find(parent[x]);
       return  parent[x]; 
   }
   ```

4. 按秩合并

   秩：指一棵树的层数

   ```c++
   void union(int x,int y){
       int x1 = find(x);
       int y1 = find(y);
       if(Rank[x1])>Rank[y1])
           parent[y1] = x1;
       else{
           parent[x1] = y1;
           if(Rank[x1]==Rank[y1])
               Rank[x1]++;
       }
   }
   ```

# 最短路

## 无权最短路广搜

一个无权图，给定一个起点和一个终点，求从起点到终点的最短步数

分析：使用广搜，谁先搜到谁最短

```c++
const int max = (int)1e4;
queue<int> q;  //队列
int vector<int> G[max]; //邻接表
int pre[max];  //前驱
void bfs(int start,int end){  //传入起点，终点
    q.push(start);
    while(!q.empty()){
        int s = q.top();
        q.pop();//队头出队
		for(auto i : G[s]){
			if(!vis[i]){  //如果没被看过
                q.push(i);
                D[i] = D[s] + 1; //记录路径
                pre[i] = s;  //记录前驱
            }
        }
    }
    return D[end];
}
```

## 弗洛伊德(Floyd)算法

有权图：边带有权值的图

边权：两点之间的距离

最短路径：从源点到终点的所有路径中，边权之和最小的那一条路径

多源最短路径问题：求任意两顶点之间的最短路径

```c++
int floyd(int s,int f){
    for(int k = 0 ; k < M ; ++k)
        for(int i = 0 ; i < M ; ++i)
            for(int j = 0 ; j < M ; ++j)
                D[i][j] = min(D[i][j],D[i][k] + D[k][j]);
}
//D[i][j]记录从i到j的路径长度，不能到达为无穷，对角线为0
```

动态规划

需要证明当计算D\[i][j] 的最小值时，D\[i][k]和D\[k][j]都取得了最小

证明后续添加

## 迪杰斯特拉(Dijkstra)算法

```c++
int D[max]; //表示某点到源点的最短路，初始化D[0] = 0;
int Pre[max]; //表示前驱数组,初始化pre[0]为0;其他无所谓
bool B[max]; //蓝白点标记,初始化为0
int w[max][max]; //矩阵，到自己为0，没有边为INF，有边存权
for(int i = 0 ; i < M ; ++i){
        int min = INF;
        int k = 0;
    //初始化该点到原点的最小值
    //初始化该点
    for(int j = 0 ; j < M ; ++j)
        if(!B[j] && D[j] < min){
            k = j;
            min = D[j];
        }
    //选取到源点距离最小的点
    B[k] = 1; //染色
    for(int j = 0 ; j < M ;++j)
    	if(!B[j] && D[k] + W[k][j] < D[j]){
            D[j] = D[k] + W[k][j];
        	Pre[j] = k;
        }
    //更新这个点相邻的点到源点的距离        
}
```

## 福特(Ford)算法

遍历边

```c++
struct edge{
    int u;
    int v;
    int w;
} edges[max]; //边集数组
D[max]; //某点到源点的距离 
for(int i = 1 ; i < N ; ++i){ //遍历n-1次
	for(int j = 0 ; j < M ; ++j){ //遍历所有边
        int u = edges[j].u;
        int v = edges[j].v;
        int w = edges[j].w;
        if(D[v] + w < D[u] ){
            D[u] = D[v] + w;
            Pre[u] = v;
        }
        if(D[u] + w < D[v]){
            D[v] = D[u] + w;
            Pre[v] = u;
		}
    }
}
```

## SPFA算法

```c++
D[max]; //某点距离源点的最远距离
vector<edge> G[max];
int W[max][max];
int exist[max];
queue<int> q; //队列

void ford(int s)
{
    q.push(s);
    while(!q.empty())
    {
        int tmp = q.front();
		q.pop();
        exsit[i] = false;
        for(int i : G[tmp])
			if(D[tmp] + W[tmp][i] < D[i])
            {
                D[i] = W[tmp][i] + D[tmp];
                pre[i] = tmp;
                if(!exist[i])
                {
                    q.push(i);
                    exist[i] = true;
                }
            }
    }
}

```

# 拓扑排序和AOV网

# 强连通分量
