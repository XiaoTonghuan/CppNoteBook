[TOC]



# 总述

## 逻辑结构

- 线性结构

  如：``array,vector,deque``

- 图形结构

- 树形结构

  ``tree``

- 集合结构

## 物理结构

指的是数据的存储结构

- 顺序存储 ： 一段连续的内存空间
- 连续存储 ：把数据放进任意的存储空间里

## 抽象数据类型

$$
指一组性质相同的值的集合及定义在此集合上的一些操作的总称
$$

- 比如：整型，浮点型，字符型
- 原子类型：不可再分的如整型
- 结构类型：整型数组是由若干整型组成的
- 抽象：指抽取出事物具有的普遍性的本质，他要求抽出问题的特征而忽略非本质的细节，是对具体事物的概括 
- 类似类

### 抽象数据类型标准模式

$$
\begin{align*}
&ADT \;抽象数据类型名\\
&Data\\
&\quad数据元素之间逻辑关系的定义\\
&Opertion\\
&\quad操作\\
&endADT

\end{align*}
$$



# 算法

- 解决特定问题求解步骤的描述，指令的有限序列、
- 算法的特性：输入，输出，有穷性，确定性，可行性
- 算法的要求：发明和创造！不是单纯背模板
  1. 正确性
  2. 可读性
  3. 健壮性
  4. 时间复杂度和空间复杂度

## 算法的效率和度量方法

- 事后统计方法：使用测试数据和测试程序

- 事前统计方法：

  - 算法采用的策略方案

  - 编译产生的代码质量

  - 问题的输入规模

    例：如等差数列求和公式，当输入数据规模为1，两者都执行一次，当输入规模极大时，公式的长处就显现出来。

    ```c++
    //朴素算法：
    for(int i = 0 ;i < n;i++)
        sum+=i;
    //求和公式
    sum = ((n+1) * n)/2;
    
    //两种方法差别是1和n
    ```

  - 机器执行指令的速度

## 时间复杂度的计算

- 函数的渐近增长：

$$
给定两个函数F（n）,G(n), \exists \,n\in\,N_+,\\当n>N_+时,F(n)>G(n)恒成立,称F(n)的增长渐进快于G(n).
$$

![image-20210114185037056](E:\C-NoteBook\数据结构\assets\image-20210114185037056.png)

### 时间复杂度

定义：
$$
语句的总执行次数T(n)是关于问题规模n的函数,
表示为T(n)=O(f(n))，\\他表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同。\\称作算法的渐进时间复杂度,f(n)是问题规模n的某个函数
$$

O写法

- ``O(1)``

```c
printf("my mother");
printf("my mother");
printf("my mother");
printf("my mother");
printf("my mother");
```

- ``O(n)`` 线性增长

```c++
for(int i = 0;i<n;i++)
{
    cout<<1;
}
```

- ``O(n^n)`` 嵌套for循环

```c++
for(;;)
    for(;;)
        for(;;)
            ...
```

- ``O(logn)`` 对数阶，比如二分

```c++
while(i<n)
{
    i*=2;
}
```

- 函数调用的时间复杂度的分析

相乘！

```c++
n++;
function(n);
for(i = 0 ; i < n ;i++){
function(i);
}
for(i = 0;i<n;i++){
    for(j = i; j<n; j++){
        printf("%d",j);
    }
}
//1+1+n+(n+n-1+...+1) = n^2;
```

- 常见时间复杂度

$$
O(1)<O(longn)<O(n)<O(nlongn)<n(n^2)
$$

- 乘法和加法哪个快

  在以前，计算机算乘法比算加法慢得多，现在发展出了特殊的算法和优化手段，乘法的运算速度已经和加法接近，有时会超越加法。

### 空间复杂度

- 空间换时间：比如动态规划，查表！





