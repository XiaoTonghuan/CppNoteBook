# 树的定义
## 定义
1. 树是由n（n>=0）个元素组成的有限集合（**set**），n=0 时称为空树。
2. 每个元素称为结点（node）（不是节点！）
3. 每一棵树都有一个特定的结点称为根结点或者树根（**root**）（树根只有一个）
4. n>1时，除根结点之外的**每个**结点（这个结点是子树的根）能分为m（m>=0）个**互不相交**的有限集合，每一个集合又是一棵树，称为根的子树（**SubTree**）
5. 一棵树由树根和他的子树组成。
## 树的基本概念
1. 树是递归定义的，即在树的定义过程中又用到了树这个概念
2. 结点（node）
   1. 一棵树（非空树）至少有一个结点，这个结点是根结点，他没有前驱（不是所有的根结点都没有前驱），其余所有结点都有唯一的前驱。
   2. 树的结点（这个节点是这棵树的根）包括唯一的数据元素，和若干指向其子树的分支。
   3. 结点拥有子树的个数称为结点的度（**degree**），度为0的结点称为**叶节点(leaf)**，度不为0的结点称为**分支结点**或者**非终结点**，根以外的分支节点称为**内部节点**，树中各节点的度的最大值称为这棵树的度。
   4. 两个节点由一条线段链接（这条线段称为树枝），上端结点是下端结点的**父结点**或者**双亲结点(parents)**，下端节点是上端结点的子结点（**child**），同一个父节点的多个子结点互为兄弟结点（**sibling**）。
   5. 从根结点到某个子结点所经过的所有节点称为该结点的祖先
   6. 称以某个节点为根的子树中的任意结点都是该结点的子孙。
3. 层次（level）
   1. 一棵树根节点的层次，为**1**，子节点的层次为其父节点的层次+1。
   2. 层次最大值为该树的**深度(height)**。
4. 路径
   1. 树中任意两个不同的结点，如果从一个结点出发沿着树枝能够到达另一个结点，称它们之间存在着一条路径。
   2. 路径用所经过的结点序列表示。
   3. 路径的长度等于路径上的结点个数 - 1.
   4. 不同子树的结点之间不存在路径
   5. 一定能找到一条路径，使根节点能够到达子节点。
5. 森林 (forest)： 指互不相交树的并集。

## 树的表示

1. 图形表示法，类似图
2. 嵌套集合表示，如其名
3. 凹入表表示法：类似一本书的目录
4. 广义表表示法：如(A,( B,(C),(D),(E) ), ( F,(G),(H) ) )

# 树的遍历

1. 前序遍历

   先遍历结点后遍历左树然后遍历右树。

2. 中序遍历

   先遍历左树然后遍历结点然后遍历右树

3. 后序遍历

   先遍历先左树后右树然后结点
   
4. 层序遍历

   如题  //用队列，相当于广搜

   ```c++
   void level_order(BTnode* root){
       std::queue<BTnode*> que;
       que.push(root->leftTree);
       que.push(root->rightTree);
       while(!que.empty())
       {
           if(que.front()->leftTree != nullptr)
           que.push(que.front()->leftTree);
           if(que.front()->rightTree != nullptr)
           que.push(que.front()->rightTree);
   
           if(!que.front()) v.push_back(0);
           else push_back(que.front()->data);
           que.pop();
       }
   }
   ```

# 二叉树(binary tree)

## 定义

n个结点的有限集合，n=0，为空树，n>0时，分成一个结点和两个集合，结点是这棵树的根节点，两个集合有分别构成这棵树的两个子树。

- 每个节点都有左右子树，但是子树可能是空树，左右不是对称的

  例如由三个结点构成的所有树有2个，二叉树有5个

  <img src="E:\C-NoteBook\数据结构\树.assets\graph (1)-1612918033936.png" style="zoom:50%;" />

  <img src="E:\C-NoteBook\数据结构\树.assets\graph (2)-1612918033937.png" alt="graph (2)" style="zoom:50%;" />

  <img src="E:\C-NoteBook\数据结构\树.assets\graph (3)-1612918033937.png" alt="graph (3)" style="zoom:50%;" />

  <img src="E:\C-NoteBook\数据结构\树.assets\graph (4)-1612918033937.png" alt="graph (4)" style="zoom:50%;" />

  <img src="E:\C-NoteBook\数据结构\树.assets\graph-1612918033938.png" alt="graph" style="zoom:50%;" />

## 二叉树的性质

1. 二叉树在第i层上的结点个数$2^{i-1}$(i>=1)个，空结点也算
2. 深度为k的二叉树的结点数<=$2^k-1$ （k>0）

3. 对于一棵非空的二叉树T，如果其叶节点的个数为$n_0$，其度为2的结点的个数为$n_2$，那么$n_0 = n_2 + 1$

   即：度为0的结点数 = 度为2的结点数 + 1

   证明：一棵二叉树只有三种结点，度为0的结点$n_0$，度为1的结点$n_1$，度为2的结点$n_2$，那么，总结点$n=n_1+n_2+n_0$ ，又 ： 总结点数 - 1 = 总树枝数 ，而总树枝数 = $n_1+ 2*n_2$ 综上 $n_0 = n_2+1$

4. **满二叉树**：每层都有最大结点的二叉树（没有空子树）

5. **完全二叉树**：满二叉树最下层从**右向左连续**删除若干个结点的二叉树

6. 有n个结点的完全二叉树的深度$[\log_2^{\;n}] + 1$

7. 如果满二叉树或者完全二叉树按照**从上到下，从左到右**的顺序编号，那么

   - 编号为i的结点的左子结点的编号为$2\cdot i$

   - 编号为i的结点的右子结点的编号为$2\cdot i  + 1$
   - 编号为i的结点的父结点的编号为$[i/2]$

## 二叉树的遍历

```c++
#include<iostream>
using namespace std;
template<class T>
struct BTNode  //结点
{
    BTNode() = default;
    BTNode(T val) :data(val),leftTree(0),rightTree(0) {}
    T data;  //数据
    BTNode* leftTree; //左指针
    BTNode* rightTree; //右指针
};
template<class T>
class Btree
{
public:
    Btree() :root_node(nullptr) {}
    void CreateTree() { this->CreateTree(root_node); }  //建树
    void FirstOrderTree() { this->FirstOrderTree(root_node); } //先根遍历
private:
    BTNode<T>* root_node; //根节点
    void CreateTree(BTNode<T>*&);
    void FirstOrderTree(BTNode<T>*&);
};
template<class T>
void Btree<T>::CreateTree(BTNode<T>*& node){  //建树
    T val = 0;
    cin >> val;
    if (val){
        node = new BTNode<T>(val);
        CreateTree(node->leftTree);
        CreateTree(node->rightTree);
    }else{
        node = nullptr;
        return;
    }       
}
template<class T>
void Btree<T>::FirstOrderTree(BTNode<T>*& node){  //先根遍历
    if (node){
        cout << node->data << endl;
        FirstOrderTree(node->leftTree);
        FirstOrderTree(node->rightTree);
    }else
        return;
}
int main()
{
    Btree<int> t;
    t.CreateTree();
    t.FirstOrderTree();
    system("pause");
}

```

### 其他问题

- 根据中根遍历和后根遍历或者中根遍历和先根遍历的序列可以重建一棵树

  证明：

- 当左子树不存在时中序和后序遍历相同

  当右子树不存在时先序遍历和中序遍历相同

  上面两种情况下先序和后序遍历均相反


## 二叉树的储存

1. 完全二叉树

   可以使用一维数组来储存

   将完全二叉树从上往下，从左往右进行编号，放进一维数组中

   ```c++
   int full_binary_tree[max + 1];
   for(int i = 1 ; i <= max ; ++i)
       cin>>full_binary_tree[i];
   //取任意一个结点的左子节点
   	full_binary_tree[2*i];
   //右子节点
   	full_binary_tree[2*i+1];
   //父节点
   	full_binary_tree[i/2];
   //注意，这是下标从1开始
   ```

2. 链表存二叉树

   ```c++
   struct BTnode{
       char data;
       BTnode* lc;
       BTnode* rc;
   } _root;
   //依然是根据编号确定位置，不过，现在可以自由
   void create_tree(BTnode*& node){  //注意这里传入的是指针的地址
   	char data;
       cin>>data;
       if(data){  //数据不是0，插入数据
   		node = new BTnode;
           node->data = data;
           //放入结点
           create_tree(node->lc); //建左树
           create_tree(node->rc); //建右树
       }else{ //0那么设为空指针
   		node = nullptr;
           return;
       }
   }
   ```

3. 数组模拟链表储存二叉树

   ```c++
   struct BTnode{
       char data;
       int lc;
       int rc;
   } tree_nodes[max];
   //用for循环？
   ```

## 重建二叉树

1. 层序遍历重建二叉树  //没测过，不知道对不？估计不对，这个应该是完全二叉树

   ```c++
   void create_tree(BTnode*& root,int*arr,int i,int len){  //注意这里传入的是指针的地址
       if(arr[i]== 0|| i>=len){
           root = nullptr;
           return;
       }
       else{
           root = new BTnode;
           root->data = arr[i];
           create_tree(root->left,arr,2*i+1,len);
           create_tree(root->left,arr,2*i+2,len);
       }
   }
   ```

2. 层序遍历重建二叉树

   ```c++
   int index = 0;
   std::queue<BTnode*> que;
   que.push(p);
   for(int i = 0 ; i < len ; ++i){
       if(arr[i]!=0){
           BTnode * tmp = que.front();
           que.push(tmp->left);
           que.push(tmp->left);
           tmp = new BTnode;
   		tmp->data = arr[index];
           que.pop();
       }
       else{
           que.front() = nullptr;
           que.pop();
       }
   }   ///我也不知是对是错，网上没找到
   ```

   

# 线索二叉树

## 定义

给定一个二叉树遍历的序列，求其中某一结点的前驱和后继，将节点中指针指向空的结点改为指向他的前驱或者后继，并添加标记，表示这个指针指向子树还是前驱后继。

```c++
typedef struct TBTNode{
	char data;  //数据
	int ltag,rtag;  //左右标记，是前驱后继还是左右子树
	struct TBTNode *lchild;  //左指针
	struct TBTNode *rchild;  //右指针
} TBTNode;
```

## 线索化二叉树

递归到最底层是空，为pre初值，最左下叶节点前驱是空（pre），空的右子树也是空，指向本身（空），将本次的结点保存为上一次遍历的结点，然后回归到上一层节点，上一层结点左子树不是空，上一个的右子树是空，修改他上一个的右子树指向该次遍历的结点。

也就是在一次修改的过程中，修改的是本次的前驱，指向上一次保存的pre，和上一次的后继，指向这一次遍历的数据

1. 中序遍历线索化二叉树

   ```c++
   //中序遍历进行中序线索化
   void inThreading(ThrBiTree T, ThrBiTree &pre){  
       if(T){  
           inThreading(T->lchild, pre);//左子树线索化  
     
           if(!T->lchild){ //当前结点的左孩子为空  
               T->lTag = 1;  
               T->lchild = pre;  
           }else{  
               T->lTag = 0;  
           }  
           if(pre!=nullptr && !pre->rchild){ //前驱结点的右孩子为空  
               pre->rTag = 1;  
               pre->rchild = T;  
           }else{  
               pre->rTag = 0;  
           }  
           pre = T;          
           inThreading(T->rchild, pre);//右子树线索化  
       }  
   }  
   //增加头节点，形成循环链表
   ```

2. 前序遍历

   ```c++
   void preThreading(ThrBiTree T, ThrBiTree &pre){  
       if(T){
           if(!T->lchild){ //当前结点的左孩子为空  
               T->lTag = 1;  
               T->lchild = pre;  
           }else{
               T->lTag = 0;
           }
           if(!pre && !pre->rchild){ //前驱结点的右孩子为空,前驱结点不为空  
               pre->rTag = 1;  
               pre->rchild = T;  
           }else{
               T->rTag = 0;
           }  
           pre = T;
           if(T->lTag != 1)  //如果不加判断会死循环??????
           	preThreading(T->lchild, pre);//左子树线索化
           if(T->rTag != 1)
           preThreading(T->rchild, pre);//右子树线索化  
       }  
   }
   ```

3. 后序遍历

   ```c++
   void pastThreading(ThrBiTree T, ThrBiTree &pre){  
       if(T){
           pastThreading(T->lchild, pre);//左子树线索化
           pastThreading(T->rchild, pre);//右子树线索化  
           if(!T->lchild){ //当前结点的左孩子为空  
               T->lTag = 1;  
               T->lchild = pre;  
           }else{
               T->lTag = 0;
           }
           if( pre!=nullptr && !pre->rchild){ //前驱结点的右孩子为空,前驱结点不为空  
               pre->rTag = 1;  
               pre->rchild = T;  
           }else{
               T->rTag = 0;
           }  
           pre = T;
       }  
   }
   ```

## 求解特定节点的后继和前驱



1. 先根遍历

   - 左子结点存在，左子节点是后继，右子节点存在，右子节点是后继，都不存在P->rc是后继线索

     ```c++
     struct BTnode{/*...*/};
     BTnode* presuc(BTnode *node){
         if(node->tag == 0) return node->lc;  //说明做指针是左子树，不是前驱指针
         else return node->rc;
     }
     ```


## 线索化下的遍历



# 树的储存

1. 父亲表示法

每个结点存父亲和数据

```c++
struct Nodes{
    int data;
    int index;
} tree[max];
```

2. 孩子表示法

节点放线性表，将头结点和他所有的孩子相关

```c++
struct Nodes{
    int data; //保存数据
    vector<Nodes> children;  //保存孩子
} tree[max];  //下标是结点编号
```

3. 父亲孩子表示法

```c++
struct Nodes{
    int data; //保存数据
    vector<Nodes> children;  //保存孩子
    int father;
} tree[max];  //下标是结点编号
```

4. 孩子兄弟表示法(二叉链表表示法，二叉树表示法)

一个指针指向第一个孩子，一个指针指向自己的下一个兄弟

```c++
struct Nodes{
    int data;
    Nodes * FirstSon;
    Nodes * NextBrother;
} tree[max];
```

# 哈夫曼树(Huffman tree)

## definition

给定一组数$w_1,w_2,...w_n$作为叶子节点的权值构造一棵二叉树。如果$WPL = \displaystyle\sum_{i=1}^nw_iL_i $ 最小（其中$L_i$为$w_i$对应的叶子节点到根节点的路径长度），则称此二叉树为最优二叉树，也称哈夫曼树并称WPL为带权路径长度

## 哈夫曼算法

1. W = $\{ w_i | i\in N_+ \}\;,\;T = \{ T_i | T_i = w_i \}\; T_i$只有根节点左右子树都是空的树
2. 从T_i中选出权值最小的两棵树,构成一颗权值为两树权值之和，左右子树为两棵子树的新树,将他并入树集,并将原来的两棵树从集合中删去
3. 重复此过程直到只剩下一棵树

```c++

```













# 搜索二叉树

# B（B+）树

# 红黑树

# AVL树

# 平衡二叉树

# 题目

## BST(binary search tree)

- 重建搜索二叉树

Question：输入搜索二叉树的后续遍历结果，重建此二叉树，并返回他的头节点

```c++
struct TreeNode 
{
 int val;
 TreeNode *left;
 TreeNode *right;
 TreeNode() = default;
 TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 TreeNode* CreatTree(int arr[], int L, int R)
 {
	 if (L > R) return nullptr;
	 TreeNode* head = new TreeNode(arr[R]);
	 int M = L - 1;
	 for (int i = L; i < R; i++)
		 if (arr[i] < arr[R])
			 M = i;
     //二分优化，不一定是完全有序才能使用二分，只要大体上有序就可以！
     /*	int M = L - 1;
	int right = R - 1;
	int left = L;
	while (right>=left)
	{
		int mid = left + ((right - left) >> 1);  //位运算那一段要加括号
		if (arr[mid] < arr[R])
		{
			M = mid;
			left = mid + 1;
		}
		else
		right = mid - 1;
	}*/
	 head->left  = CreatTree(arr, L, M);
	 head->right = CreatTree(arr, M + 1, R - 1);
	 return head;
 }
};
void PrintTree(TreeNode*head)
{
	if (head == nullptr) return;
	cout << head->val << endl;
	PrintTree(head->left);
	PrintTree(head->right);
}
int main()
{
	int arr[]{ 1,4,3,7,6,9,13,12,8 };
	TreeNode Tree1;
	TreeNode *Treehead = Tree1.CreatTree(arr, 0, 8);
	PrintTree(Treehead);
}
```

Test：[1,4,3,7,6,9,13,12,8]

