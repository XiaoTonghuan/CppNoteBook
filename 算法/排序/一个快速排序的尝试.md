一个快速排序的尝试

# 代码演示1
``` c++
#include<iostream>
using namespace std;
void QuickSort ( int arry[], int l,int r) //传入数组地址，传入左边界和右边界 
{
	if ( l >= r )
	{
		return ;
	}     //这个应该是递归边界，递归没学看不懂。
	int left = l; int right =r; int pivot = arry[ left ] ; //定义可以变化的左右边界。
	while (left < right ) // 左右边界不重合时，一次快速排序，一次快速排序只能移动2个数字。 
	{
		while ( left <right && arry[ right ] >= pivot ) //从最右边起判断基准值和右边数字的大小，如果右边数字大，保持原位置不变，有边界自减1. 
		{
			right--;
		}
		if ( left < right && arry[right] < pivot) //当右面的数字比基准值小时，将他放入最左面。这时最左面的数字已经赋值给基准值。 
		{
			arry[left] = arry[right] ;
		}
		while ( left < right && arry[left] <= pivot ) //和上面同样，只不过这次是把比基准值小的数字放在左面。左面数字比基准值小，保持原位置不动，左边界自加1。 
		{
			left++ ;
		}
		if (left < right && arry[left] > pivot )
		{
			arry[right] =arry[left] ; //将过大的数字放到基准值的右侧，此时被替换的数字已经换掉了最左面的数字 
		}
		if (left >= right ) 
		{
			pivot = arry[left]; //某次完成上面的代码时，出现了left=right的情况，代表一次排序完毕，将基准值放回arry[left]处 
		}
	}
	QuickSort (  arry ,l,right-1 ); //将基准值左边的部分排序
	QuickSort (  arry, left+1,r  );//将基准值右侧的部分排序 
	
} 
int main ()
{
	int arry[9] = { 5,3,9,8,65,2,1,63,47} ;
	cout<<"输出排序前的数组"<<endl;
	int lenth = sizeof(arry) / sizeof(arry[0]) ;
	for(int i=0 ;i<lenth ; i++)
	{
		cout<<arry[i]<<" ";
	} 
	QuickSort ( arry , 0 , lenth-1 );
	cout<<"输出排序之后的数组"<<endl;
	for(int i=0 ;i<lenth ; i++)
	{
		cout<<arry[i]<<" ";
	} 
}
```
# 原理说明
1. 将数组的第一个数字定义为基准值。
2. 从右向左看将第一个遇见的比基准值小的值放到最左侧。
3. 从左向右看，将第一个遇见的比基准值大的值放到上一步第一次遇见符合条件数字的位置。
4. 当左右边界重合时，把基准值放回中间。
5. 这样，基准值左边就全是比基准值小的数字，基准值右边就全是比基准值大的数字。
6. 递归，对基准值左边和右边的数组重新快速排序，直至最后数组的长度为0。（左右边界重合）
