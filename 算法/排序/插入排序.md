插入排序

``` c++
#include<iostream>
using namespace std;
void	InsertSort(int arry[], int len)
{
	for (int i = 1; i < len; i++)
	{
		int j = i - 1; //j是被排序的数前一个数的下标。
		int key = arry[i]; //记录需要排序的数，用来比较和插入。
		while (j >= 0 && arry[j] > key) //当前面还有数字且这个数字比需要排序的数字大时，将这个数字向前移动一位。
		{
			arry[j + 1] = arry[j]; //向前移动一位
			j--; //将下标自减，便于下一次的比较
		}
		arry[j + 1] = key; //当找到插入的地方时，直接插入。
	}
}
int main()
{
	int arry[10] = { 1,555,369,5488,326,124,203,2136,32,15 };
	cout << "数组未排序前是" << endl;
	int len = sizeof(arry) / sizeof(arry[0]);
	for (int i = 0; i < len; i++)
	{
		cout << arry[i] << " ";
	}
	cout << "排序后的数组为" << endl;
	InsertSort(arry, len);
	for (int i = 0; i < len; i++)
	{
		cout << arry[i] << " ";
	}

}
```
# 介绍
1. 将第二个数（设定第二个数为key）与第一个数（第一个数是有序数列）进行比较，如果前面比后面的大，将后面的插入前面的之前（实际上是交换了两者的位置）
2. 完成第一趟循环。
3. 将这两个数的下标向前移动一位（ 这两个数变为第二和第三个数，将第三个数设定为key，key不随第三个数的变化而变化。）
4. 判断第key和第二个数的大小，如果第二个数比key大，用第二个数覆盖第三个数，同时，将第二个数的下标减1，现在下标为第一个数。再把第一个数和key比较，符合条件覆盖第二个数。下标自减1。不满足循环条件，跳出循环。
5. 将key（第三个数）插入第一个位置。
6. 下标加一，key变为第四个数，重复上述过程。直至成为有序的数列。

## 希尔排序
1. 希尔排序是改进的插入排序
2. 首先将数组分成几组，每组都插入排序，然后减少组的数量继续插入排序，直至成为有序的数列。
``` c++
#include<iostream>
using namespace std;
void	JumpInsertSort(int arry[], int len)
{

	for (int start = len / 2 ; start > 0 ; start /= 2 ) //外侧的循环控制的是分组的个数，先上来分成n/2个组，每个组都插入排序。
	{
	for (int i = start; i < len; i++)  //唯一的区别开始的下标改变了。
	{
		int j = i - 1;
		int key = arry[i];
		while (j >= 0 && arry[j] > key)
		{
			arry[j + 1] = arry[j];
			j--;
		}
		arry[j + 1] = key;
	}
	
	}
}
int main()
{
	int arry[10] = { 1,555,369,5488,326,124,203,2136,32,15 };
	cout << "数组未排序前是" << endl;
	int len = sizeof(arry) / sizeof(arry[0]);
	for (int i = 0; i < len; i++)
	{
		cout << arry[i] << " ";
	}
	cout << "排序后的数组为" << endl;
	JumpInsertSort(arry, len);
	for (int i = 0; i < len; i++)
	{
		cout << arry[i] << " ";
	}
    system("pause") ;

}
```