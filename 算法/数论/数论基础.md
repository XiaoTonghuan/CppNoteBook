# 整除

$$
a|b\\
a\not|\,\,\,b
$$

$a$整除$b$

## 性质

1. 传递性：$a|b\;,b|c \Rightarrow a|c$
2. $a_1+...|a_n =0\;,k|a_1,...k|a_{n-1}\Rightarrow k|a_n$     
   - $k$整除a，$k$整除a的相反数
   - $k$整除每一个加数，$k$整除这个数
3. 任何一个整数都能写成带余除法的形式
   - $\forall a,b \in Z(a>b>0)\Rightarrow \exists \;q,r \in Z:a=bq+r(0<=r<b)$

# 唯一分解定理

$$
n = p_1^{k_1}\cdot p_2^{k_2}\cdot...\cdot p_n^{k_n} ,\; p_1<p_2<...<p_n
$$

推论：

- 因子的个数：$num = (k_1 + 1)\cdot(k_2+1)\cdot...\cdot(k_n+1)$
- 因子之和：$sum = (p_1+p_1^{2}+...+p_n^{k_1}) \cdot ...\cdot(p_n+p_n^{2}+...+p_n^{k_n})$

# 质数定理

$$
\pi(n) 为不小于n的质数的个数\\
\pi(n) \sim \frac{n}{ln^n}
$$

- 可以看出随着n的增大质数个数的增长越来越接近于线性增长
- 质数的间隔逐渐变小

# 欧拉函数

$$
\Phi(n) 表示小于n的和n互质的数的数量
\\
\Phi(n) = n\cdot(1-\frac{1}{p_1})\cdot(1-\frac{1}{p_2})\cdot...\cdot(1-\frac{1}{p_m})
$$

- $\Phi(1) = 1 , \Phi(n)=n-1(n为质数)$

- 欧拉函数是积性函数$\Phi(xy) = \Phi(x)\cdot\Phi(y)$

- 证明：
  $$
  p是质数\Phi(p^k) = p^k - p^{k-1}\\
  早0-p^k的范围内，1，p，2p，...p^{k-1}p 和 p^{k}不互质，共p^{k-1}个数字\\
  又欧拉函数是积性函数：p(n) = p(p_1^{k_1})*...*p(p_m^{k_m})带入得到欧拉函数表达式
  $$

- 若x,y互质，那么$\Phi(xy) = \Phi(x) \cdot (y-1)$ ，否则$\Phi(xy) = \Phi(x)\cdot y$

  第二条证明：
  $$
  \Phi(xy) = xy(1-\frac{1}{p_1})\cdot...\cdot(1-\frac{1}{p_n}) = y \cdot \Phi(x)
  $$

  ```c++
  //利用欧拉筛求欧克函数
  const int n = 100000;
  
  int prime[n];  //质数表
  bool vis[n];   //标记 false是质数 true是合数
  int tot;       //个数
  int phi[n];    //欧拉函数
  
  //初始化
  phi[1] = 1;
  vis[0] = vis[1] = true;
  
  void eular(int num){
      for(int i = 2 ; i <= num ; ++i){
  		if(!vis[i]){
              prime[tot++] = i;
              phi[i] = i - 1;
           }
          for(int j = 0 ; j < tot && i * prime[j] <= num ; ++j){
  			vis[ i * prime[j]] = true;
              phi[ i * prime[j] ] = phi[i] * (prime[j] - 1); // 假设两者互质，phi(xy) = phi(x) * (y-1)其中y是质数
              if( i % prime[j] == 0){
                  //如果不互质
                  phi[ i * prime[j] ] = phi[i] * prime[j];
  				break;
              }
          }
      }
  }
  ```
## [HDU P2824 欧拉函数](http://acm.hdu.edu.cn/showproblem.php?pid=2824)

  ```c++
  #include<iostream>
  #include<vector>
  #include<string>
  #include<algorithm>
  using namespace std;
  //利用欧拉筛求欧克函数
  const int n = 3000001;
  
  int prime[n];  //质数表
  bool vis[n];   //标记 false是质数 true是合数
  int tot;       //个数
  int phi[n];    //欧拉函数
  
  void eular(int num){
      phi[ 1 ] = 1;
      vis[ 0 ] = vis[ 1 ] = true;
      for(int i = 2 ; i <= num ; ++i){
  		if(!vis[i]){
              prime[tot++] = i;
              phi[i] = i - 1;
           }
          for(int j = 0 ; j < tot && i * prime[j] <= num ; ++j){
  			vis[ i * prime[j]] = true;
              phi[ i * prime[j] ] = phi[i] * (prime[j] - 1); // 假设两者互质，phi(xy) = phi(x) * (y-1)其中y是质数
              if( i % prime[j] == 0){
                  //如果不互质
                  phi[ i * prime[j] ] = phi[i] * prime[j];
  				break;
              }
          }
      }
  }
  int main()
  {
      long long N  = 0;
      int a , b;
      cin>>a>>b;
      eular(b);
      for(int i = a ; i <= b ; ++i )
          N += phi[i];
      cout << N;    
      system("pause");
  }
  ```
# 欧拉定理

$$
a和n互质，那么a^{\Phi(n)} 和 1 对 n 同余 \\
a^{\Phi(n)} \equiv 1(mod \;n)
\\当n为质数时，退化为费马小定理\\
a,p互质，那么\\
a^{p-1} \equiv 1(mod\; p)
$$



  # 威尔逊定理

$$
p为质数，那么\\
(p-1)! \equiv p - 1 (mod \;p)
$$



# 卢卡斯定理



# 逆元(inv)

$$
如果 ax\equiv 1(mod \;b) 称x为a模b的乘法逆元\\
显然有：ax = by + 1 令y = -y 则有 ax + by = 1，因此逆元存在的充要条件是gcd(a,b) = 1
$$



- 可以直接用拓展欧几里得求解

- 如果b是个质数

  $ 根据费马小定理 a^{p-1}\equiv 1(\mod p) 又 ax \equiv 1(\mod p) 前面等价于 (a\cdot a^{p-2}) \equiv 1 (\mod   p) \Rightarrow x = a^{p-2}\mod p$

  注意上面取模运算的乘法分配律所以$a^{p-2}\mod p$

- 在取模运算中$\frac{a}{b} \mod m$ 的值就为 $a \cdot inv(b) \mod m$

## 拓展欧几里得求逆元

```c++
int exgcd(int a,int b,int& x,int& y){
	if(b==0){
		x = 1;
		y = 0;
		return a;
	}
	int d = exgcd(b,a%b,y,x);
	y -= a/b * x;
	return d;
}
int inv(int a,int p){
    int x = 0 , y = 0;
    if(exgcd(a,p,x,y) != 1) return -1;
    else return (x % p + p)%p  //防止x是负数
}
```

## 费马小定理

```c++
int quick_pow(int b,int p,int m){
    int res = 1;
    while(p > 0){
		if( p & 1 ) 
			res = res * b % m;
        p >>= 1;
        b =  b % m * b % m ;
    }
    return res;
}

int inv(int a,int p){
    if(isnp(p))
        return quick_pow(a,p-2,p);
    else
		return -1;
}
```

