# 素数判别法

1. 使用纯枚举判断的方法，枚举到根下n即可

   ```c++
   //使用函数的版本，写法和简洁程度都得到了优化，此外这也是判断一个数是不是质数的标准代码
   bool isnp(int n)
   {
       if(n==1) return false;
       for(int i = 2;i*i<=n;i++)
           if(n%i==0) return false;
       return true;
   }
   ```


2. 我们知道大于5的素数分布在6的倍数的两侧 如 $7,11,13,17,19...$

   ```c++
   bool isnp(int n)
   {
     if(n == 1) return false;
     else if(n==2 || n==3 || n==5) return true;
     if(n%6 != 1 && n%6 != 5) return false;
     for(int i = 5; i*i <=n ;i+=6)
     		if(n%i==0 || n%(i+2)==0) return false; //*素数的倍数一定是合数*
     return true;
   }
   ```
   
3. Miller_Rabin

   首先来看费马小定理和二次探测定理
$$
   if\;(\gcd(a,p) = 1,p为素数)\;\Longrightarrow (a^{p-1}  \equiv 1 (mod\;p))
   $$
   
   $$
   if\;(p是素数,\forall\;0<x<p,对方程:x^2\equiv 1(mod\;p)) \; \Longrightarrow (x = 1 \;or \;x = p-1)
   $$
   
   
   
   ```c++
   
   ```
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   



# 无脑算法

## 原始版本

1. 算法说明：枚举从2到n-1的所有数，查看这里面有没有n的因数,没有就是素数。

```c++
void NormalEd(int n)
{
        cout << 2 << endl; //由于枚举的可能因子是2到j-1的所有数字,j必须>=3，因此不含2，所以提前输出最小素数2。
        for (int j = 3; j <=n; j++)  //外循环用来枚举所有的数字。
            for (int i = 2; i <= j - 1; i++) //内循环用来枚举可能的因数。
                if (j % i == 0)  //存在因数则这个数字不是素数。
                    break;
                else if (i == j-1)  //如果有幸到n-1还没能被整除，这个数为质数
                    cout << j << endl;
}
```

2. 同一算法的其他想法：
   1. 可以定义一个计数器，计算n被整除的次数。当n被整除2次时（从1到n），这个数是质数。这个方法的时间复杂度为稳定的N的平方。
   2. 可以定义一个标记，赋初值为1，当n为合数时将他赋值为0，重新开始循环时重置。

## 改进版本

 将一个质数枚举所有可能因数的次数缩减到$\sqrt{n}$ 

```c++
for (int n = 2; n <= 100; n++)  
        for (int i = 1; i <= (int)sqrt(n); i++)  //循环n的所有可能因数
            if (n % i == 0 && i != 1)  //如果n能被2到根下n之间某一个数整除，这个数不是质数。
                break;
            else if ( i >= (int)sqrt(n) )  //如果i自增到根下n（当根下n是个无理数）还没有被整除，他一定是质数
                cout << n << endl;
```

时间复杂度$O(n*\sqrt{n})$

# 埃式筛法

1. 算法说明：
   素数的倍数一定不是素数,素数前面第一个没有被筛去的数一定是素数。
2. 算法事项
   1. 给要枚举的所有数字一个标记（数组中存放标记，数组下标是枚举的数字；当然你也可以数组套数组，外层数组放标记，内层数组放数字，这样下标就仅仅是下标而已。）
   2. 素数的标记赋值为0（先假设所有的数字都是素数），合数的下标赋值为1。
   3. 枚举这些数字，当标记显示这个数字为素数的时候，更改这个素数所有倍数的标记为1（说明这个素数的倍数为合数）
   4. 重复枚举的步骤。

```c++
//给出一个数字n，打印从2到n的所有质数。
#define MAX 1000
void SieveOfEra(int n)
{
	
	bool isprime[MAX] = {1,1,0}; //数组存放数字的标记。 
	for (int i = 2; i <= n; i++) //枚举所有的数字
	{
		if (!isprime[i]) //判断是否是素数
		{
			for (int j = 2; j * i <= n; j++)
			{
				isprime[j * i] = 1;  //调整素数倍数的标记，说明这些数字不是素数。
			}
		}
	}
	
	for (int i = 0; i < n; i++) //打印这些标记为0的数字。
	{
		if (isprime[i] == 0)

			cout << i << endl;
	}
}
```

时间复杂度：n \*素数的倒数之和根据
$$
Merten's\;theorem\\
\lim_{n \to \infty}(\sum_{p\le n}\frac{1}{p} - \ln^{ln^n} -M) = 0 \\
M=0.261...
$$


$O(n*\log^{log^n})$

# 欧拉筛（线性筛）

1. 算法说明：
   1. 保证每一个合数只能被他的最小素数筛去。
   2. 一个合数可以分解为一个质数和另一个数的乘积（不包括1）。（如果可以分解为质数×合数的形式，那么必有一组分解使得质数最小，合数最大。）
   3. 标记质数×质数类型时要保证枚举到的那个素数大于素数表中的素数这样保证素数×素数类型只能被枚举到一次。如（6 = 3 * 2，6=2 * 3 ，只需要在枚举到3的时候将他标记。）
   4. 标记合数×质数类型时，只要找到他的最小素因数（由于这个质数×合数，可能能分解为更小质数乘一个更大的合数，因此标记这个数的任务就交给枚举的那个更大合数的时候完成）然后标记即可，这样可以保证他只被标记了一次。
   5. 举个例子：如，当你要枚举到4*3之前，先判断能不能被更小的素数整除，发现4%2==0，也就是说3×4有更小质数的分解

```c++
#define max 1000
void EulerS(int n)
{
    int prime[max] = { 0 };
    bool check[max] = {1,1, 0 };
    int pos = 0;
    for (int i = 2;i <= n;i++)  //枚举所有数
    {
        if (!check[i])  //将素数存入素数表。
            prime[pos++] = i;
            for (int j = 0;j < pos && i * prime[j] <= n; j++)  //j<pos来保证只能筛掉比当前素数小的素数与这个素数的乘积。
            {
                check[i*prime[j]] = 1;  //任何一个合数都能分解成质数的乘积，将合数筛掉。
                if (i % prime[j] == 0)  //当i为合数时保证每个数只能筛掉一次
                    break;
            }
    }

    for (int i = 0; i <= n;i++)
        if (!check[i])
            cout << i << endl;
}

int main()
{
    EulerS(100);
}
```

时间复杂度：$O(n)$

# 普通筛法的几个写法

## 数组标记法

```c++
bool prime[1000]{0}; //数组只用来标记，只有0和1两种状态。
void isnotprimep()
{
    //将下标当做所要遍历的数，
	for(int i = 2 ; i<=2000 ;i++)
		if(!prime[i])
			for(int j = 2 ; j*i<=2000 ; j++)
				prime[i*j] = 1 ;
}
```

## 直接筛选法

```c++
#include <iostream>
using namespace std;
int prime[1000]{0};
void isnotprime(int n) //筛选法，将素数的倍数直接变为0
{
	for(int i=2;i<=n;i++) //枚举，从2到n。
		if(prime[i]) //判断i是否为质数，第一个数2一定为质数。
			for(int j=i*2;j<=n;j+=i) //将质数的倍数删去
				prime[j] = 0; 
}
void initialp(int n) //初始化数组，将0到n填入数组中。
{
	for (int i = 0; i <= n; i++)
		prime[i] = i;
}
void printp(int n)  //打印
{
	for (int i = 0; i <= n; i++)
		if(prime[i])
			cout<<prime[i]<<" "<<endl;
}
int main()
{
	initialp(100);
	isnotprime(100);
	printp(100);
}
```

## 滚动数组法

```c++
//确实的将质数的倍数从数组中删去了，而不是将他变为0
int prime[1000]{0};
void isnotprime(int n)
{
	while(1) //死循环走起
	{	int cnt = 2; //计数器为2
		cout<<prime[2]<< endl; //第一个数字肯定为质数
		if(prime[2]>prime[3]) //当全部筛完之后，只有第一个数是质数，第一个数一定大于第二个数。
			break;
		int flag = prime[2]; //将第一个质数设置为因字
		for(int j=2; j<=n; j++) //遍历
			if(prime[j]%flag) //不是flag的倍数，则向前覆盖一位，cnt++避免再次覆盖。
				prime[cnt++] = prime[j];
	}
}
void initialp(int n)
{
	for (int i = 0; i <= n; i++)
		prime[i] = i;
}
int main()
{
	initialp(100);
	isnotprime(100);
}
```

# Question

1. 键盘输入m和n（10<m<n≤32000），求出m~n间所有素数且按每行8个数形式输出。

```c++
#include<iostream>
using namespace std;
bool isnotprime(int n)
{
    for(int i = 2;i*i<=n;i++)
        if(n%i==0) return false;
    return true;
}
int main()
{
    int m,n;
    cin>>m>>n;
    int flag = 0;
    for(int i = m;i<=n;i++)
        if(isnotprime(i))
        {
            cout<<i<<" ";
            flag++;
            if(flag==8)
            {
                cout<<endl;
                flag = 0;
            }
		}
}

```

2. 完数问题：若有一数，其值等于它的因子之和，则该数称为完数。例如，6的因子为1、2、3，而6=1+2+3，故6是完数。编程输出1000之内的所有完数及其因子。

```c++
for(int j=2;j<=1000 ;j++)
{ 
    int temp =j;
    int b=j;
    for(int i=2;i<b;i++)
        if(b%i==0)
            temp-=i;
    if(temp==1)
    {
    	for(int i=2;i<b;i++)
			if(b%i==0)
				cout<<i<<" ";
		cout<<endl<<j<<endl;
	}
}
```
3. 编写出判断一个整数是否为素数的函数，并求出在2000以内的有十个以上的所有连续的非素数组。
```c++
bool isnp(int n)
{
    for(int i=2;i*i<=n;i++)
        if(n%i==0) return 0;
    return 1;
}
int main()
{
    int b[1000]{0};
    int flag=1;
    for(int i=2;i<=2000;i++)
        if(isnp(i)) 
		{
			if(flag>=10)
        	{
            	for(int i=0;i<flag;i++)
                	cout<<b[i]<<" ";
            	cout<<endl;
        	}
			flag=0;
		}
        else
            b[flag++] = i;
}
```


