# 非递归二分查找

```c++
int arr[10]={1,4,78,90,123,432,654,768,789,999};
int search(int target, int len)
{
	int left = 0 , right = len-1;
	while(right>=left) //一个区间开闭的问题，找到最后闭区间内能够包含一个数字，而开区间不行！ 
	{
		int mid = (left+right)/2; //left+right在数据较大时可能会溢出，所以应该写成mid = (right-left)/2 + left
		if(arr[mid] == target) 
		return mid;
		else if(target>arr[mid]) 
		left = mid+1;
		else if(target<arr[mid])
		right = mid -1;
	}
	if(right < left)
	return -1;
}

int main()
{
	int target;
	cin>>target;
	int len =sizeof(arr)/sizeof(arr[0]);
	cout<<search(target , len);
 } 
```



# 递归二分

```c++
int arr[10]={1,4,78,90,123,432,654,768,789,999};
int search(int target, int len)
{
	int left = 0 , right = len-1;
    int mid = (left+right)/2;
	if(arr[mid] == target) return mid; 
	if(target>arr[mid]) return search(mid+1,right);
    if(target<arr[mid]) return search(left,mid-1);
	if(right < left)
	return -1;
}

int main()
{
	int target;
	cin>>target;
	int len =sizeof(arr)/sizeof(arr[0]);
	cout<<search(target , len);
 } 
```

# 插值查找

1. 不一定一定要二分，也可以1/4分等等，这要求我们调整mid的值。
2. 插值涉及到离散数学的知识**插值拟合**

$$
\frac{mid - left}{right - left} = \frac{arr[mid]-arr[left]}{arr[right]-arr[left]}
$$



```c++
mid = left + (arr[mid]-arr[left])/(arr[right]/arr[left])*(right-left)//其他的完全一样
```

