# 10 $\to$ n

## 算法描述

使用短除法可以将十进制转换为任意进制，我们可以使用循环或者递归来模拟这一过程。
$$
2|\underline{313}\quad1\\
\quad 2|\underline{156}\quad0\\
\qquad 2|\underline{78}\quad0\\
\qquad\quad2|\underline{39}\quad1\\
\qquad\qquad2|\underline{19}\quad1\\
\qquad\qquad\quad2|\underline{9}\quad1\\
\qquad\qquad\qquad2|\underline{4}\quad0\\
\qquad\qquad\qquad\quad2|\underline{2}\quad0\\
\qquad\qquad\qquad\qquad2|\underline{1}\quad1\\
$$

## 递归

```c++
void transbits(int bits, int num, char* str, int& flag)
{
    if (!num) return;
    transbits(bits, num / bits, str, flag);
    str[flag++] = char(num % bits + 48);
}
```

利用递归的特点可以使数字倒着存放，不能转换16进制，因为$ASC$数字和字母不连着。

- 递归为什么能够简洁的完成这个任务？

  因为递归是栈，最后计算的最先出现结果，也可以使用栈完成相同的任务。

  ```c++
  void transbits(int bits, int num, char* str)
  {
      stack<int> s;
      while(num>0)
      {
          s.push(num%10);
          num/=10;
      }
      int i = 0 ;
      while(!s.empty())
      {
          str[i++] = char(48+s.top());
          s.pop();
      }
  }
  ```

## 循环

```c++
void transbits(int bits, int num, string &str)
{
    while(num!=0)
    {
    	str.insert(str.begin(),char(num%bits+48));
    	num/=bits;
	}
}
```

## 类似拓展

1. 编制一个程序，读入一个正整数，并反向输出。例如，读入123，输出是321。

   - $solution$ : 就是将整型的十进制数转化为string十进制数，并输出。

2. 水仙花数问题：水仙花数是一种三位数，它的值等于每个数字的立方和。例如，153=13+53+33。编程输出小于999的水仙花数。

   - $solution$ ：用和上面一模一样的方法，多了一步验证

3. 编程求出1000以内的所有符合如下条件的数：其高位数字小于低位数字。如12，238等。但21，548不符合条件。

   - $solution$：也用了类似上面的处理方法先对10取模然后除以10，然后不停循环
4. 正读和反读都一样的数称为回文数。编写程序输入一个整数，输出从0到整数中用二进制表示和十进制表示都是回文数的整数。定义一个函数is_circle_num()判断一个数（number）在某个进制（radius）下是否为回文数。例如，整数313就是该程序输出的一个数，因为它的二进制表示为10011001。
## Code

1. ```c++
   int main()
   {
    int a;
    cin>>a;
    for(int i=0;a!=0;i++)
    {
        cout<<a%10;
        a=a/10;
    }
   }
   ```

2. ```c++
   int main()
   {
       for(int i = 100;i<=999;i++)
       {
           int a = i%10;
           int b = i/10%10;
           int c = i / 100;
           if(a*a*a+b*b*b+c*c*c==i)
               cout<<i<<endl;
       }
   }
   ```

3. ```c++
   int main()
   {
       for(int i=10; i<=1000;i++)
       {
           bool flag = true;
           int temp = i;
           while (temp!=0) //注意考虑判断条件
           {
              if(temp%10<=temp/10%10)
               flag = false;
               temp/=10;
           }
           if(flag) cout<<i<<endl;
       }
   }
   ```


# n $\to$ 10

将每一位和权相乘再相加

```c++
int transtoten(int bits,string str)
{
	int sum=0;
	for(int i=str.size()-1;i>=0;i--)
		sum+=((int)str[i] - 48)*pow(bits,(str.size()-i-1));
	return sum;
}
```

# 练习

## P9(leetcode)

![image-20210112134939871](E:\C-NoteBook\算法\基本算法\picture\image-20210112134939871.png)

```c++
class Solution {
public:
    bool isPalindrome(int x) 
    {
        if(x<0) return false;
        long long  cmp = 0; //使用整型可能会在数字较大时爆掉!，如果爆掉了一定不是回文数
        long long  y = x;
        while(x>0)
        {
            cmp*=10;
            cmp += x%10;
            x/=10;
        }
        if(cmp == y) return true;
        else return false;
        //上面两句可简写为return cmp==y;
    }
};
//这是不使用字符串的写法
```

```c++
class Solution {
public:
    bool isPalindrome(int x) 
    {
        if(x<0) return false;
        if(x==0) return true;
        string str = to_string(x);
        string str1 = "";
        while(x>0)
        {
            str1.insert(str1.end(),char(x%10 + 48));
            x/=10;
        }
        return str==str1;
    }
};
```

